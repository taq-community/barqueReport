---
title: "Rapport d'Analyse Métagénomique - 12S"
subtitle: ""
date: today
lang: fr
crossref:
  tbl-title: "Tableau"
params:
  barque_output_folder: "/home/steve/Documents/git/barque/12_results"
  config_file: "/home/steve/Documents/git/barque/99_logfiles/20251120_181640_barque_config.sh"
  primer_file: "/home/steve/Documents/git/barque/99_logfiles/20251120_181640_primers.csv"
  samples_ids: ["M1", "M2", "M3", "M4", "M5"]
  title_short: "Rapport 12S"
  sampling_date: ""
  lab_author: ""
  bioinfo_author: ""
  report_author: ""
title-short: "`r params$title_short`"
client-name: "`r params$client_name`"
cover-image: "`r system.file('images/cover.png', package = 'barqueReport')`"
lab-author: "`r params$lab_author`"
bioinfo-author: "`r params$bioinfo_author`"
report-author: "`r params$report_author`"
format:
  pdf:
    template: template.tex
    toc: true
    toc-depth: 2
    toc-title: "Table des matières"
    number-sections: true
    highlight-style: github
    colorlinks: true
    keep-tex: false
    include-in-header:
      text: |
        \definecolor{customblue}{HTML}{3a6881}
        \hypersetup{linkcolor=customblue, urlcolor=customblue, citecolor=customblue}
execute:
  echo: false
  warning: false
  message: false
---

```{r setup}
library(dplyr)
library(readr)
library(knitr)
library(kableExtra)
library(ggplot2)

# Load barque data
barque_data <- barqueReport::load_barque_data(params$barque_output_folder, params$samples_ids)
single_hits <- barque_data$single_hits
multi_hits <- barque_data$multi_hits

# Calculate stats
stats <- barqueReport::barque_summary_stats(single_hits, multi_hits, params$samples_ids)

# Load dropout data
dropout_data <- readr::read_csv(file.path(params$barque_output_folder, "sequence_dropout.csv"), show_col_types = FALSE) |>
  dplyr::filter(Sample %in% params$samples_ids)

# Calculate metrics
metrics <- dropout_data |>
  dplyr::summarise(
    brutes = sum(`04_data`, na.rm = TRUE),
    trimmed = sum(`05_trimmed`, na.rm = TRUE),
    merged = sum(`06_merged`, na.rm = TRUE),
    split = sum(`07_split_amplicons`, na.rm = TRUE),
    chimeres = sum(`08_chimeras`, na.rm = TRUE),
    annotees = sum(`12_results`, na.rm = TRUE)
  )

# Extract config values
config_lines <- readLines(params$config_file)

get_config <- function(param) {
  line <- grep(paste0("^", param, "="), config_lines, value = TRUE)
  value <- gsub("^[^=]+=([0-9.]+).*", "\\1", line)
  as.numeric(value)
}

config <- list(
  min_hits_sample = get_config("MIN_HITS_SAMPLE"),
  min_hits_experiment = get_config("MIN_HITS_EXPERIMENT")
)

# Extract primer properties (header is first line with #, data is first line without #)
primer_lines <- readLines(params$primer_file)
primer_header <- strsplit(sub("^#", "", primer_lines[1]), ",")[[1]]
primer <- read_csv(params$primer_file, comment = "#", col_names = primer_header, show_col_types = FALSE) |>
  as.list()
```

# Information sur le projet

Ce rapport présente les résultats de l'analyse métagénomique 12S réalisée pour `r params$client_name` dans la région de `r params$geographic_region`. L'objectif de cette étude est l'identification de la diversité des espèces aquatiques. L'échantillonnage a été réalisé par `r params$client_name` dans `r params$geographic_region` en `r params$sampling_date`. Au total, `r stats$samples` échantillons ont été analysés pour le marqueur 12S (`r paste(params$samples_ids, collapse = ", ")`).

# Méthodes & Résultats

## Extraction d'ADN

### Méthode d'extraction d'ADNe

La méthode d'extraction d'ADN environnemental est décrite dans Sandré et al. 2025 (doi.org/10.1002/edn3.70179). La moitié de chaque réplicat terrain est extraite et combinée pour former un réplicat technique à séquencer.

L'ADN environnemental est extrait dans une salle spécialisée et décontaminée. Le personnel porte en tout temps un sarrau propre et des gants stériles. Le personnel est formé pour la décontamination et les exigences que demande le travail avec les échantillons d'ADN environnemental.

## Métagénomique en laboratoire

L'analyse utilise les amorces 12S MiFish-U-F et U-R (Miya et al. 2015), avec une taille d'amplicon de 174 bp. L'approche PCR repose sur une combinaison unique de 2 barcodes de 8 bp. Aucune dilution n'est effectuée, et 3 µl d'ADN sont utilisés par réplicat de PCR. Cinq réplicats techniques sont réalisés par échantillon testé, avec 35 cycles PCR. Le séquençage est effectué sur MiSeq i100, Illumina Inc.

## Analyse bio-informatique

Le post-traitement des données séquencés est effectué avec BARQUE (https://github.com/enormandeau/barque). Le pipeline BARQUE traite les séquences en plusieurs étapes successives. Les séquences brutes obtenues du séquenceur passent d'abord par une étape de *trimming* pour retirer les amorces et les portions de mauvaise qualité. Ensuite, les lectures 3" et 5" sont combinées (*merge*) pour reconstituer l'amplicon complet. L'étape de *split* permet de classifier les amplicons selon les marqueurs ciblés afin de conserver ceux d'une longueur supérieure à `r primer$MinAmpliconSize` et inférieure à `r primer$MaxAmpliconSize`. Les séquences chimériques, qui sont des artefacts de PCR, sont ensuite éliminées.


```{r}
#| label: tbl-results-summary
#| tbl-cap: "Résumé de l'analyse métagénomique 12S"

results_data <- data.frame(
  Parametre = c(
    "Nombre total de séquences",
    "Nombre total de séquences annotées",
    "Nombre d'espèces détectées",
    "Nombre de groupes ambigus (Multiple Hits)",
    "Taux d'annotation"
  ),
  Valeur = c(
    format(metrics$brutes, big.mark = " "),
    format(metrics$annotees, big.mark = " "),
    as.character(stats$single_species),
    as.character(stats$multi_groups),
    paste0(round((metrics$annotees / metrics$brutes) * 100, 1), "% des séquences brutes")
  )
)

knitr::kable(results_data, col.names = c("", ""))
```


```{r}
#| label: tbl-sequencing-steps
#| tbl-cap: "Tableau du nombre de lectures écartées lors du post-traitement des données de séquençage par le pipeline Barque"

# Prepare data with samples in rows and steps in columns
steps <- c("04_data", "05_trimmed", "06_merged", "07_split_amplicons", "08_chimeras", "12_results")
step_labels <- c("Brutes", "Trimming", "Merge", "Split", "Chimères", "Annotées")

sequencing_data <- data.frame(Sample = character(), stringsAsFactors = FALSE)

for (sample_id in params$samples_ids) {
  sample_dropout <- dropout_data |> dplyr::filter(Sample == sample_id)
  values <- c(
    sample_dropout$`04_data`,
    sample_dropout$`05_trimmed`,
    sample_dropout$`06_merged`,
    sample_dropout$`07_split_amplicons`,
    sample_dropout$`08_chimeras`,
    sample_dropout$`12_results`
  )
  brutes <- values[1]
  row_data <- c(format(brutes, big.mark = " "), sapply(2:length(values), function(i) {
    diff <- values[i-1] - values[i]
    pct <- round(diff / brutes * 100, 1)
    paste0(format(values[i], big.mark = " "), " (-", pct, "%)")
  }))
  sequencing_data <- rbind(sequencing_data, c(sample_id, row_data))
}

colnames(sequencing_data) <- c("Échantillon", step_labels)

# Add total row
total_values <- c(
  sum(dropout_data$`04_data`),
  sum(dropout_data$`05_trimmed`),
  sum(dropout_data$`06_merged`),
  sum(dropout_data$`07_split_amplicons`),
  sum(dropout_data$`08_chimeras`),
  sum(dropout_data$`12_results`)
)
total_brutes <- total_values[1]
total_row <- c("Total", format(total_brutes, big.mark = " "), sapply(2:length(total_values), function(i) {
  diff <- total_values[i-1] - total_values[i]
  pct <- round(diff / total_brutes * 100, 1)
  paste0(format(total_values[i], big.mark = " "), " (-", pct, "%)")
}))
sequencing_data <- rbind(sequencing_data, total_row)

knitr::kable(sequencing_data, format = "latex", booktabs = TRUE) |>
  kableExtra::kable_styling(latex_options = c("scale_down", "hold_position")) |>
  kableExtra::row_spec(nrow(sequencing_data) - 1, extra_latex_after = "\\midrule")
```

 Finalement, les séquences restantes sont annotées en les assignant à une espèce présente dans la base de données contenue dans le pipeline BARQUE. Cette base de données est constituée des séquences de référence de MitoFish (Iwasaki et al. 2013), GenBank ainsi que des séquences de référence de l'Institut de biologie intégrative et des systèmes (IBIS) à Laval. Pour obtenir une identification positive, le niveau de similarité minimale entre la séquence obtenue et celles présentes dans la base de données de référence a été fixé à `r primer$SimilSpecies * 100`%.

Les espèces qui n'ont pas fait l'objet d'une detection d'au moins `r config$min_hits_sample` séquences dans un échantillon et au moins `r config$min_hits_experiment` séquences sur l'ensemble des échantillons sont retirées de l'analyse afin de limiter les erreurs d'identification (Brown et al., 2015; Schnell, Bohmann, & Gilbert, 2015).


```{r}
#| label: fig-reads-filtered-out
#| fig-cap: "Figure du nombre de lectures écartées lors du post-traitement des données de séquençage par le pipeline Barque"
#| fig-width: 10
#| fig-height: 6

# Load and process sequence dropout data
dropout_long <- barqueReport::load_dropout_data(params$barque_output_folder, params$samples_ids) |>
  dplyr::mutate(
    step_label = dplyr::case_when(
      step == "04_data" ~ "Séquences brutes",
      step == "05_trimmed" ~ "Filtration",
      step == "06_merged" ~ "Fusion",
      step == "07_split_amplicons" ~ "Classification",
      step == "08_chimeras" ~ "Retrait chimères",
      step == "12_results" ~ "Séquences finales",
      TRUE ~ step
    ),
    step_order = dplyr::case_when(
      step == "04_data" ~ 1,
      step == "05_trimmed" ~ 2,
      step == "06_merged" ~ 3,
      step == "07_split_amplicons" ~ 4,
      step == "08_chimeras" ~ 5,
      step == "12_results" ~ 6,
      TRUE ~ 0
    )
  ) |>
  dplyr::arrange(Sample, step_order)

# Create ggplot2 plot
ggplot2::ggplot(dropout_long, ggplot2::aes(x = stats::reorder(step_label, step_order), y = sequences, group = Sample, color = Sample)) +
  ggplot2::geom_line(linewidth = 0.8, alpha = 0.8) +
  ggplot2::geom_point(size = 2.5, alpha = 0.8) +
  ggplot2::scale_colour_manual(values = grDevices::colorRampPalette(MetBrewer::met.brewer("Signac", 13))(length(params$samples_ids))) +
  ggplot2::scale_y_continuous(labels = scales::label_number(big.mark = " ")) +
  ggplot2::labs(
    x = "",
    y = "Nombre de séquences",
    color = "Échantillons"
  ) +
  ggplot2::theme_light(base_size = 12) +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
    legend.position = "right",
    panel.grid.minor = ggplot2::element_blank()
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = 3)))
```

{{< pagebreak >}}

# Liste des espèces détectées

Les détections d'espèces sont classifiées en trois niveaux de confiance basés sur le nombre de lectures de séquences d'ADN :

| Statut de détection | Nombre de lectures assignées | Interprétation |
|---------------------|-------------------|----------------|
| Confiant | > 100 lectures | Détection avec un signal d'ADN fort |
| Probable | 10-100 lectures | Détection à confiance modérée |
| Incertain | < 10 lectures | Détection à faible confiance, peut nécessiter une vérification supplémentaire |

: Niveaux de confiance des détections {#tbl-confidence-levels}

Le nombre de lectures assignées reflètent les concentrations d'ADN détectées dans l'échantillon et assignées à une espèces, mais ne sont pas directement proportionnels à l'abondance des organismes en raison des variations dans le processus d'amplification et séquencage en laboratoire, l'autoécologie des espèces et la qualité de la bases de données de références utisée.

```{r}
# Create cache file path
cache_dir <- file.path(params$barque_output_folder, ".cache")
if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)
cache_file <- file.path(cache_dir, "species_info_cache.rds")

# Check if cache exists and is newer than source file
source_file <- file.path(params$barque_output_folder, "12s200pb_species_table.csv")
use_cache <- file.exists(cache_file) &&
             file.exists(source_file) &&
             file.mtime(cache_file) > file.mtime(source_file)

if (use_cache) {
  # Load from cache
  barque_species <- readRDS(cache_file)
  message("Loaded species info from cache")
} else {
  # Process and cache
  barque_species <- barqueReport::barque_species(source_file) |>
    dplyr::mutate(Species = paste(Genus, Species)) |>
    dplyr::pull(Species) |>
    barqueReport::process_species_info()

  # Save to cache
  saveRDS(barque_species, cache_file)
  message("Processed species info and saved to cache")
}
```

```{r}
#| label: species-by-sample
#| results: asis

# Function to classify detection confidence
classify_detection <- function(reads) {
  dplyr::case_when(
    reads > 100 ~ paste0("Confiant \\\\ ", format(reads, big.mark = " "), " lectures assignées"),
    reads >= 10 ~ paste0("Probable \\\\ ", format(reads, big.mark = " "), " lectures assignées"),
    TRUE ~ paste0("Incertain \\\\ ", format(reads, big.mark = " "), " lectures assignées")
  )
}
species_consolidated <- barque_species |>
    dplyr::group_by(
        species,
        English,
        French,
        gbif_url,
        col_link,
        itis_url
    ) |>
    dplyr::summarise(
        Native_Quebec = any(native == TRUE & !is.na(Quebec)),
        Exotic_Quebec = any(exotic == TRUE & !is.na(Quebec)),
        .groups = "drop"
    )


status_qc <- read.csv(system.file("extdata/QC_especes_en_peril.csv", package = "barqueReport"))
status_ca <- read.csv(system.file("extdata/CA_especes_en_peril.csv", package = "barqueReport"))

# Join conservation status data
# Remove duplicates from conservation status files by keeping the first occurrence
status_ca_unique <- status_ca |>
  dplyr::select(species = Nom.scientifique, status_ca = Statut.à.l.annexe.1) |>
  dplyr::distinct(species, .keep_all = TRUE)

status_qc_unique <- status_qc |>
  dplyr::select(species = Nom_scientifique, status_qc = STATUT_LEMV) |>
  dplyr::distinct(species, .keep_all = TRUE)

species_consolidated <- species_consolidated |>
    dplyr::left_join(
        status_ca_unique,
        by = c("species")
    ) |>
    dplyr::left_join(
        status_qc_unique,
        by = c("species")
    ) |>
    dplyr::mutate(
        status_ca = ifelse(status_ca == "Aucun statut", NA, status_ca),
        status_qc = ifelse(status_qc == "Non suivie", NA, status_qc))

# Generate sections for each sample
for (sample_id in params$samples_ids) {
  # Print main section header for this sample (with pagebreak)
  cat("\n\n{{< pagebreak >}}\n\n## Échantillon : ", sample_id, "\n\n", sep = "")

  # --- Subsection 1: Single hits (espèces détectées) ---
  sample_species <- single_hits |>
    dplyr::select(Group, Species, dplyr::all_of(sample_id)) |>
    dplyr::rename(Reads = dplyr::all_of(sample_id)) |>
    dplyr::filter(Reads > 0) |>
    dplyr::mutate(Détection = classify_detection(Reads)) |>
    dplyr::arrange(desc(Reads)) |>
    dplyr::select(Group, Species, Détection) |>
    dplyr::left_join(species_consolidated, by = c("Species" = "species")) |>
    dplyr::mutate(
      Espèce = paste0(
        "\\begin{tabular}[t]{@{}l@{}}",
        ifelse(!is.na(French), French, "Nom vernaculaire inconnu"),
        " \\\\ \\textit{", Species, "} \\\\ ",
        "\\href{", gbif_url, "}{Distribution} \\textbar{} \\href{", itis_url, "}{Taxonomie}",
        "\\end{tabular}"
      ),
      `Statut Québec` = ifelse(!is.na(status_qc), status_qc, "-"),
      `Statut Canada` = ifelse(!is.na(status_ca), status_ca, "-")
    ) |>
    dplyr::select(Group, Espèce, Détection, `Statut Québec`, `Statut Canada`)

  cat("### Espèces détectées\n\n")

  if (nrow(sample_species) > 0) {
    print(knitr::kable(
      sample_species,
      col.names = c("Groupe", "Espèce", "Détection", "Statut Québec", "Statut Canada"),
      format = "latex",
      label = NA,
      escape = FALSE,
      booktabs = TRUE,
      longtable = TRUE
    ) |>
      kableExtra::kable_styling(
        latex_options = c("repeat_header"),
        font_size = 10
      ))
  } else {
    cat("*Aucune espèce détectée dans cet échantillon.*\n\n")
  }

  # --- Subsection 2: Multiple hits (détections ambiguës) ---
  # Filter out Incertain groups (reads < 10)
  sample_multi <- multi_hits |>
    dplyr::select(Species, dplyr::all_of(sample_id)) |>
    dplyr::rename(Reads = dplyr::all_of(sample_id)) |>
    dplyr::filter(Reads >= 10) |>
    dplyr::mutate(Statut = classify_detection(Reads)) |>
    dplyr::arrange(desc(Reads))

  cat("\n\n### Détections ambiguës\n\n")

  if (nrow(sample_multi) > 0) {
    # Expand each row into multiple rows (one per species)
    # First remove "Hits " prefix, then split by " : " delimiter
    sample_multi_expanded <- sample_multi |>
      dplyr::mutate(
        group_id = dplyr::row_number(),
        # Remove "Hits " prefix from Species
        Species_clean = sub("^Hits ", "", Species),
        Species_list = strsplit(Species_clean, " : ")
      ) |>
      tidyr::unnest(Species_list) |>
      dplyr::group_by(group_id) |>
      dplyr::mutate(
        # Split species into Genus Species (format: Group_Genus_species -> Genus species)
        Species = gsub("_", " ", sub("^[^_]+_", "", Species_list))
      ) |>
      dplyr::ungroup() |>
      dplyr::left_join(species_consolidated, by = c("Species" = "species")) |>
      dplyr::select(group_id, Reads, Statut, Species, French, gbif_url, itis_url, status_qc, status_ca)

    # Create final table with group and species in rows
    sample_multi_final <- sample_multi_expanded |>
      dplyr::group_by(group_id) |>
      dplyr::mutate(
        n_species = dplyr::n(),
        row_num = dplyr::row_number()
      ) |>
      dplyr::ungroup() |>
      dplyr::arrange(group_id, Species) |>
      dplyr::mutate(
        # Use multirow for Groupe column
        Groupe = dplyr::if_else(
          row_num == 1,
          paste0("\\multirow{", n_species, "}{*}{\\textbf{Groupe ", group_id, "}}"),
          ""
        ),
        # Use multirow for Détection column
        Détection = dplyr::if_else(
          row_num == 1,
          paste0("\\multirow{", n_species, "}{*}{", Statut, "}"),
          ""
        ),
        # Format species name
        Espèce = paste0(
          "\\begin{tabular}[t]{@{}l@{}}",
          ifelse(!is.na(French), French, "Nom vernaculaire inconnu"),
          " \\\\ \\textit{", Species, "} \\\\ ",
          "\\href{", gbif_url, "}{Distribution} \\textbar{} \\href{", itis_url, "}{Taxonomie}",
          "\\end{tabular}"
        ),
        `Statut Québec` = ifelse(!is.na(status_qc), status_qc, "-"),
        `Statut Canada` = ifelse(!is.na(status_ca), status_ca, "-")
      ) |>
      dplyr::select(Groupe, Détection, Espèce, `Statut Québec`, `Statut Canada`)

    # Build the kable
    tbl <- knitr::kable(
      sample_multi_final,
      format = "latex",
      label = NA,
      escape = FALSE,
      booktabs = FALSE,
      longtable = TRUE,
      align = c("l", "l", "l", "l", "l"),
      linesep = "",  # Remove default spacing
      vline = ""  # Remove vertical lines
    ) |>
      kableExtra::kable_styling(
        latex_options = c("repeat_header"),
        font_size = 10
      ) |>
      kableExtra::column_spec(1:5, border_left = FALSE, border_right = FALSE)

    # Add hline after each group (after the last species in each group)
    group_ends <- sample_multi_final |>
      dplyr::mutate(row_idx = dplyr::row_number()) |>
      dplyr::group_by(Groupe) |>
      dplyr::filter(Groupe != "") |>
      dplyr::summarise(last_row = max(row_idx)) |>
      dplyr::pull(last_row)

    for (row_idx in group_ends) {
      if (row_idx < nrow(sample_multi_final)) {
        tbl <- tbl |> kableExtra::row_spec(row_idx, extra_latex_after = "\\\\\\hline")
      }
    }

    print(tbl)
  } else {
    cat("*Aucune détection ambiguë dans cet échantillon.*\n\n")
  }

  cat("\n\n")
}
```

{{< pagebreak >}}

# Conclusion


## Avertissements – Limites de l'approche

Il est important de considérer les limites de ce genre d’étude en ce qui a trait aux espèces détectées. Certaines espèces ne peuvent avoir été détectées par cette méthode étant donné leur rareté (faible présence/absence) ou parce qu’elles n’étaient pas présentes à proximité des sites d’échantillonnage.

Certaines séquences d’ADN 12S ambigües (Multiple hits) sont identifiées comme appartenant à plus qu’une espèce.
Des espèces autres que les poissons ont été détectées avec les amorces 12S. Par contre, comme les amorces ne sont pas spécifiques à ces autres espèces et que la base de données n’est pas faite pour les autres espèces, les résultats obtenus ne sont là qu’à titre indicatif.

De plus, nous suggérons fortement de tenir compte d’un seuil du nombre de séquences limites pour la détection d’une espèce. Ce seuil est déterminé de manière à tenir compte des erreurs et/ou artefacts de séquençage (Brown et al. 2015) et des séquences mal attribuées aux différents échantillons (« index jumps-bleeding ») – Schnell et al 2015.

{{< pagebreak >}}

# Références

Berger C, Hernandez C, Laporte M, Côté G, Paradis Y, Normandeau E, Bernatchez L (2020) Fine-scale spatial structuration of fish communities within river revealed by environmental DNA metabarcoding. *Environmental DNA*.

Brown SP, Veach AM, Rigdon-Huss AR, Grond K, Lickteig SK, Lothamer K, Oliver AK, Jumpponen A (2015) Scraping the bottom of the barrel: are rare high throughput sequences artifacts? *Fungal Ecology* 13:221-225.

Iwasaki W, Fukunaga T, Isagozawa R, Yamada K, Maeda Y, Satoh TP, Sado T, Mabuchi K, Takeshima H, Miya M, Nishida M (2013) MitoFish and MitoAnnotator: A Mitochondrial Genome Database of Fish with an Accurate and Automatic Annotation Pipeline. *Molecular Biology and Evolution* 30(11):2531–2540.

Miya M, Sato Y, Fukunaga T, Sado T, Poulsen JY, Sato K, Minamoto T, Yamamoto S, Yamanaka H, Araki H, Kondoh M, Iwasaki W (2015) MiFish, a set of universal PCR primers for metabarcoding environmental DNA from fishes: detection of more than 230 subtropical marine species. *Royal Society Open Science* 2(7).

Sandré F, To TA, Couillard J, Bélisle A-C, Langlois VS (2025) Tracking Aquatic Biodiversity With Environmental DNA: A Study in Quebec's Mining Region. *Environmental DNA* 7(5):e70179. https://doi.org/10.1002/edn3.70179.

Schnell IB, Bohmann K, Gilbert MTP (2015) Tag jumps illuminated – reducing sequence-to-sample misidentifications in metabarcoding studies. *Molecular Ecology Resources* 15:1289-1303.

