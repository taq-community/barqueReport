---
title: "Rapport d'Analyse Métagénomique - 12S"
subtitle: ""
date: today
params:
  barque_output_folder: "/home/steve/Documents/git/barque/12_results"
  config_file: "/home/steve/Documents/git/barque/99_logfiles/20251120_181640_barque_config.sh"
  primer_file: "/home/steve/Documents/git/barque/99_logfiles/20251120_181640_primers.csv"
  samples_ids: ["M1", "M2", "M3", "M4", "M5"]
  title_short: "Rapport 12S"
  client_name: ""
  geographic_region: ""
  sampling_date: ""
  lab_author: ""
  bioinfo_author: ""
  report_author: ""
title-short: "`r params$title_short`"
client-name: "`r params$client_name`"
cover-image: "`r system.file('images/cover.png', package = 'barqueReport')`"
lab-author: "`r params$lab_author`"
bioinfo-author: "`r params$bioinfo_author`"
report-author: "`r params$report_author`"
format:
  docx:
    toc: true
  pdf:
    template: template.tex
    toc: true
    toc-depth: 2
    toc-title: "Table des matières"
    number-sections: true
    highlight-style: github
    colorlinks: true
    keep-tex: false
    include-in-header:
      text: |
        \usepackage[french]{babel}
        \usepackage{parskip}
        \definecolor{customblue}{HTML}{3a6881}
        \hypersetup{linkcolor=customblue, urlcolor=customblue, citecolor=customblue}
execute:
  echo: false
  warning: false
  message: false
---

```{r setup}
library(dplyr)
library(readr)
library(knitr)
library(kableExtra)
library(ggplot2)

# Load barque data
barque_data <- barqueReport::load_barque_data(params$barque_output_folder, params$samples_ids)
single_hits <- barque_data$single_hits
multi_hits <- barque_data$multi_hits

# Calculate stats
stats <- barqueReport::barque_summary_stats(single_hits, multi_hits, params$samples_ids)

# Load dropout data
dropout_data <- readr::read_csv(file.path(params$barque_output_folder, "sequence_dropout.csv"), show_col_types = FALSE) |>
  dplyr::filter(Sample %in% params$samples_ids)

# Calculate metrics
metrics <- dropout_data |>
  dplyr::summarise(
    brutes = sum(`04_data`, na.rm = TRUE),
    trimmed = sum(`05_trimmed`, na.rm = TRUE),
    merged = sum(`06_merged`, na.rm = TRUE),
    split = sum(`07_split_amplicons`, na.rm = TRUE),
    chimeres = sum(`08_chimeras`, na.rm = TRUE),
    annotees = sum(`12_results`, na.rm = TRUE)
  )

# Extract config values
config_lines <- readLines(params$config_file)

get_config <- function(param) {
  line <- grep(paste0("^", param, "="), config_lines, value = TRUE)
  value <- gsub("^[^=]+=([0-9.]+).*", "\\1", line)
  as.numeric(value)
}

config <- list(
  min_hits_sample = get_config("MIN_HITS_SAMPLE"),
  min_hits_experiment = get_config("MIN_HITS_EXPERIMENT")
)

# Extract primer properties (header is first line with #, data is first line without #)
primer_lines <- readLines(params$primer_file)
primer_header <- strsplit(sub("^#", "", primer_lines[1]), ",")[[1]]
primer <- read_csv(params$primer_file, comment = "#", col_names = primer_header, show_col_types = FALSE) |>
  as.list()
```

# Information sur le projet

Ce rapport présente les résultats de l'analyse métagénomique 12S réalisée pour `r params$client_name` dans la région de `r params$geographic_region`. L'objectif de cette étude est l'identification de la diversité des espèces aquatiques. L'échantillonnage a été réalisé par `r params$client_name` dans `r params$region_geographique` en `r params$sampling_date`. Au total, `r stats$samples` échantillons ont été analysés pour le marqueur 12S (`r paste(params$samples_ids, collapse = ", ")`).

# Méthodes & Résultats

## Métagénomique en laboratoire

L'analyse utilise des amroces 12S MiFish-U-F et U-R (Miya et al. 2015), avec une taille d'amplicon de 174 bp. L'approche PCR repose sur une combinaison unique de 2 barcodes de 8 bp. Aucune dilution n'est effectuée, et 3 µl d'ADN sont utilisés par réplicat de PCR. Cinq réplicats techniques sont réalisés par échantillon testé, avec 35 cycles PCR. Le séquençage est effectué sur MiSeq i100, Illumina Inc.

## Analyse bio-informatique

Le post-traitement des données séquencés est effectué avec Barque (https://github.com/enormandeau/barque). Le pipeline Barque traite les séquences en plusieurs étapes successives. Les séquences brutes obtenues du séquenceur passent d'abord par une étape de *trimming* pour retirer les amorces et les portions de mauvaise qualité. Ensuite, les lectures 3" et 5" sont combinées (*merge*) pour reconstituer l'amplicon complet. L'étape de *split* permet de classifier les amplicons selon les marqueurs ciblés afin de conserver ceux d'une longueur supérieure à `r primer$MinAmpliconSize` et inférieure à `r primer$MaxAmpliconSize`. Les séquences chimériques, qui sont des artefacts de PCR, sont ensuite éliminées.


```{r}
#| label: tbl-results-summary
#| tbl-cap: "Résumé de l'analyse métagénomique 12S"

results_data <- data.frame(
  Parametre = c(
    "Nombre total de séquences",
    "Nombre total de séquences annotées",
    "Nombre d'espèces détectées",
    "Nombre de groupes ambigus (Multiple Hits)",
    "Taux d'annotation"
  ),
  Valeur = c(
    format(metrics$brutes, big.mark = " "),
    format(metrics$annotees, big.mark = " "),
    as.character(stats$single_species),
    as.character(stats$multi_groups),
    paste0(round((metrics$annotees / metrics$brutes) * 100, 1), "% des séquences brutes")
  )
)

knitr::kable(results_data, col.names = c("", ""))
```


```{r}
#| label: tbl-sequencing-steps
#| tbl-cap: "Tableau du nombre de lectures écartées lors du post-traitement des données de séquençage par le pipeline Barque"

# Prepare data with samples in rows and steps in columns
steps <- c("04_data", "05_trimmed", "06_merged", "07_split_amplicons", "08_chimeras", "12_results")
step_labels <- c("Brutes", "Trimming", "Merge", "Split", "Chimères", "Annotées")

sequencing_data <- data.frame(Sample = character(), stringsAsFactors = FALSE)

for (sample_id in params$samples_ids) {
  sample_dropout <- dropout_data |> dplyr::filter(Sample == sample_id)
  values <- c(
    sample_dropout$`04_data`,
    sample_dropout$`05_trimmed`,
    sample_dropout$`06_merged`,
    sample_dropout$`07_split_amplicons`,
    sample_dropout$`08_chimeras`,
    sample_dropout$`12_results`
  )
  brutes <- values[1]
  row_data <- c(format(brutes, big.mark = " "), sapply(2:length(values), function(i) {
    diff <- values[i-1] - values[i]
    pct <- round(diff / brutes * 100, 1)
    paste0(format(values[i], big.mark = " "), " (-", pct, "%)")
  }))
  sequencing_data <- rbind(sequencing_data, c(sample_id, row_data))
}

colnames(sequencing_data) <- c("Échantillon", step_labels)

# Add total row
total_values <- c(
  sum(dropout_data$`04_data`),
  sum(dropout_data$`05_trimmed`),
  sum(dropout_data$`06_merged`),
  sum(dropout_data$`07_split_amplicons`),
  sum(dropout_data$`08_chimeras`),
  sum(dropout_data$`12_results`)
)
total_brutes <- total_values[1]
total_row <- c("Total", format(total_brutes, big.mark = " "), sapply(2:length(total_values), function(i) {
  diff <- total_values[i-1] - total_values[i]
  pct <- round(diff / total_brutes * 100, 1)
  paste0(format(total_values[i], big.mark = " "), " (-", pct, "%)")
}))
sequencing_data <- rbind(sequencing_data, total_row)

knitr::kable(sequencing_data, format = "latex", booktabs = TRUE) |>
  kableExtra::kable_styling(latex_options = c("scale_down", "hold_position")) |>
  kableExtra::row_spec(nrow(sequencing_data) - 1, extra_latex_after = "\\midrule")
```

 Finalement, les séquences restantes sont annotées en les assignant à une espèce présente dans la base de données contenue dans le pipeline BARQUE. Cette base de données est constituée des séquences de référence de MitoFish (Iwasaki et al. 2013), GenBank ainsi que des séquences de référence de l'Institut de biologie intégrative et des systèmes (IBIS) à Laval.  Pour obtenir une identification positive, le niveau de similarité minimale entre la séquence obtenue et celles présentes dans la base de données de référence a été fixé à `r primer$SimilSpecies * 100`%.

Les espèces qui n'ont pas fait l'objet d'une detection d'au moins `r config$min_hits_sample` séquences dans un échantillon et au moins `r config$min_hits_experiment` séquences sur l'ensemble des échantillons sont retirées de l'analyse afin de limiter les erreurs d'identification (Brown et al., 2015; Schnell, Bohmann, & Gilbert, 2015).


```{r}
#| label: fig-reads-filtered-out
#| fig-cap: "Figure du nombre de lectures écartées lors du post-traitement des données de séquençage par le pipeline Barque"
#| fig-width: 10
#| fig-height: 6

# Load and process sequence dropout data
dropout_long <- barqueReport::load_dropout_data(params$barque_output_folder, params$samples_ids) |>
  dplyr::mutate(
    step_label = dplyr::case_when(
      step == "04_data" ~ "Séquences brutes",
      step == "05_trimmed" ~ "Filtration",
      step == "06_merged" ~ "Fusion",
      step == "07_split_amplicons" ~ "Classification",
      step == "08_chimeras" ~ "Retrait chimères",
      step == "12_results" ~ "Séquences finales",
      TRUE ~ step
    ),
    step_order = dplyr::case_when(
      step == "04_data" ~ 1,
      step == "05_trimmed" ~ 2,
      step == "06_merged" ~ 3,
      step == "07_split_amplicons" ~ 4,
      step == "08_chimeras" ~ 5,
      step == "12_results" ~ 6,
      TRUE ~ 0
    )
  ) |>
  dplyr::arrange(Sample, step_order)

# Create ggplot2 plot
ggplot2::ggplot(dropout_long, ggplot2::aes(x = stats::reorder(step_label, step_order), y = sequences, group = Sample, color = Sample)) +
  ggplot2::geom_line(linewidth = 0.8, alpha = 0.8) +
  ggplot2::geom_point(size = 2.5, alpha = 0.8) +
  ggplot2::scale_colour_manual(values = grDevices::colorRampPalette(MetBrewer::met.brewer("Signac", 13))(length(params$samples_ids))) +
  ggplot2::scale_y_continuous(labels = scales::label_number(big.mark = " ")) +
  ggplot2::labs(
    x = "",
    y = "Nombre de séquences",
    color = "Échantillons"
  ) +
  ggplot2::theme_light(base_size = 12) +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
    legend.position = "right",
    panel.grid.minor = ggplot2::element_blank()
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = 3)))
```

{{< pagebreak >}}

# Liste des espèces détectées

Les détections d'espèces sont classifiées en trois niveaux de confiance basés sur le nombre de lectures de séquences d'ADN :

| Statut de détection | Nombre de lectures assignées | Interprétation |
|---------------------|-------------------|----------------|
| Confiant | > 100 lectures | Détection avec un signal d'ADN fort |
| Probable | 10-100 lectures | Détection à confiance modérée |
| Incertain | < 10 lectures | Détection à faible confiance, peut nécessiter une vérification supplémentaire |

: Niveaux de confiance des détections {#tbl-confidence-levels}

Le nombre de lectures assignées reflètent les concentrations d'ADN détectées dans l'échantillon et assignées à une espèces, mais ne sont pas directement proportionnels à l'abondance des organismes en raison des variations dans le processus d'amplification et séquencage en laboratoire, l'autoécologie des espèces et la qualité de la bases de données de références utisée.

```{r}
#| label: species-by-sample
#| results: asis

# Function to classify detection confidence
classify_detection <- function(reads) {
  dplyr::case_when(
    reads > 100 ~ paste0("Confiant (", format(reads, big.mark = " "), " lectures assignées)"),
    reads >= 10 ~ paste0("Probable (", format(reads, big.mark = " "), " lectures assignées)"),
    TRUE ~ paste0("Incertain (", format(reads, big.mark = " "), " lectures assignées)")
  )
}

devtools::load_all()
barque_species <- barqueReport::barque_species(file.path(params$barque_output_folder, "12s200pb_species_table.csv")) |> 
  dplyr::mutate(Species = paste(Genus, Species)) |> 
  dplyr::pull(Species) |>
  barqueReport::process_species_info()



# Generate sections for each sample
for (sample_id in params$samples_ids) {
  # Print main section header for this sample (with pagebreak)
  cat("\n\n{{< pagebreak >}}\n\n## Échantillon : ", sample_id, "\n\n", sep = "")

  # --- Subsection 1: Single hits (espèces détectées) ---
  sample_species <- single_hits |>
    dplyr::select(Group, Species, dplyr::all_of(sample_id)) |>
    dplyr::rename(Reads = dplyr::all_of(sample_id)) |>
    dplyr::filter(Reads > 0) |>
    dplyr::mutate(Statut = classify_detection(Reads)) |>
    dplyr::arrange(desc(Reads)) |>
    dplyr::select(Group, Species, Statut)

  cat("### Espèces détectées\n\n")

  if (nrow(sample_species) > 0) {
    print(knitr::kable(
      sample_species,
      col.names = c("Groupe", "Espèce", "Statut")
    ))
  } else {
    cat("*Aucune espèce détectée dans cet échantillon.*\n\n")
  }

  # --- Subsection 2: Multiple hits (détections ambiguës) ---
  # Filter out Incertain groups (reads < 10)
  sample_multi <- multi_hits |>
    dplyr::select(Species, dplyr::all_of(sample_id)) |>
    dplyr::rename(Reads = dplyr::all_of(sample_id)) |>
    dplyr::filter(Reads >= 10) |>
    dplyr::mutate(Statut = classify_detection(Reads)) |>
    dplyr::arrange(desc(Reads))

  cat("\n\n### Détections ambiguës\n\n")

  if (nrow(sample_multi) > 0) {
    # Expand each row into multiple rows (one per species)
    # First remove "Hits " prefix, then split by " : " delimiter
    sample_multi_expanded <- sample_multi |>
      dplyr::mutate(
        group_id = dplyr::row_number(),
        # Remove "Hits " prefix from Species
        Species_clean = sub("^Hits ", "", Species),
        Species_list = strsplit(Species_clean, " : ")
      ) |>
      tidyr::unnest(Species_list) |>
      dplyr::group_by(group_id) |>
      dplyr::mutate(
        # Add group header as first row, keep Statut only for first row
        row_num = dplyr::row_number(),
        Statut = dplyr::if_else(row_num == 1, Statut, ""),
        # Split species into Genus Species (format: Group_Genus_species -> Genus species)
        Species = gsub("_", " ", sub("^[^_]+_", "", Species_list))
      ) |>
      dplyr::ungroup()

    # Create final table with group headers
    result_list <- list()
    for (gid in unique(sample_multi_expanded$group_id)) {
      group_data <- sample_multi_expanded |> dplyr::filter(group_id == gid)
      statut_val <- group_data$Statut[1]
      # Add group header row
      result_list <- c(result_list, list(data.frame(
        Species = paste0("**Groupe ", gid, "**"),
        Statut = statut_val
      )))
      # Add species rows
      result_list <- c(result_list, list(data.frame(
        Species = group_data$Species,
        Statut = ""
      )))
    }
    sample_multi_final <- dplyr::bind_rows(result_list)

    print(knitr::kable(
      sample_multi_final,
      col.names = c("Espèce possible", "Statut")
    ))
  } else {
    cat("*Aucune détection ambiguë dans cet échantillon.*\n\n")
  }

  cat("\n\n")
}
```

{{< pagebreak >}}

# Conclusion


## Avertissements – Limites de l'approche

Il est important de considérer les limites de ce genre d’étude en ce qui a trait aux espèces détectées. Certaines espèces ne peuvent avoir été détectées par cette méthode étant donné leur rareté (faible présence/absence) ou parce qu’elles n’étaient pas présentes à proximité des sites d’échantillonnage.

Certaines séquences d’ADN 12S ambigües (Multiple hits) sont identifiées comme appartenant à plus qu’une espèce.
Des espèces autres que les poissons ont été détectées avec les amorces 12S. Par contre, comme les amorces ne sont pas spécifiques à ces autres espèces et que la base de données n’est pas faite pour les autres espèces, les résultats obtenus ne sont là qu’à titre indicatif.

De plus, nous suggérons fortement de tenir compte d’un seuil du nombre de séquences limites pour la détection d’une espèce. Ce seuil est déterminé de manière à tenir compte des erreurs et/ou artefacts de séquençage (Brown et al. 2015) et des séquences mal attribuées aux différents échantillons (« index jumps-bleeding ») – Schnell et al 2015.

{{< pagebreak >}}

# Références

Berger C, Hernandez C, Laporte M, Côté G, Paradis Y, Normandeau E, Bernatchez L (2020) Fine-scale spatial structuration of fish communities within river revealed by environmental DNA metabarcoding. Environmental DNA.

Brown SP, Veach AM, Rigdon-Huss AR, Grond K, Lickteig SK, Lothamer K, Oliver AK, Jumpponen A (2015) Scraping the bottom of the barrel: are rare high throughput sequences artifacts? Fungal Ecology 13:221-225.

Iwasaki W, Fukunaga T, Isagozawa R, Yamada K, Maeda Y, Satoh TP, Sado T, Mabuchi K, Takeshima H, Miya M, Nishida M (2013) MitoFish and MitoAnnotator: A Mitochondrial Genome Database of Fish with an Accurate and Automatic Annotation Pipeline. Molecular Biology and Evolution 30(11): 2531–2540.

Miya M, Sato Y, Fukunaga T, Sado T, Poulsen JY, Sato K, Minamoto T, Yamamoto S, Yamanaka H, Araki H, Kondoh M, Iwasaki W (2015) MiFish, a set of universal PCR primers for metabarcoding environmental DNA from fishes: detection of more than 230 subtropical marine species. R.Soc.Open sci. 2(7).

Schnell IB, Bohmann K, Gilbert MTP (2015) Tag jumps illuminated – reducing sequence-to-sample misidentifications in metabarcoding studies. Molecular Ecology Resources. 15: 1289-1303.

